# 编译原理 - 国防科技大学

## 排版说明
一级标题 课程标题
二级标题 章节
三级标题 小章节
四级标题 知识点

## 1 引论

### 1.1 什么是编译程序
> 翻译, 编译, 解释

#### 什么是翻译程序 (Translator)
源语言程序 => 目标语言程序
1. Compiler: 高级语言程序 => 低级语言程序
2. Interpreter: 源程序作为输入, 不产生目标程序, 边解释边执行源程序

#### 编辑程序分类
1. 诊断编译程序 (Diagnostic Compiler): 调试, 排错
2. 优化编译程序 (Optimizing Compiler): 优化
3. 交叉编译程序 (Cross Compiler): 产生不同于宿主机的目标机的机器代码(分 宿主机, 目标机)
4. 可变目标编译程序 (Retargetable Compiler): 改变目标机有关的部分

### 1.2 为什么要学习编译原理
1. 理解计算系统 (包括但不限 计算机系统)
2. 设计计算系统 (软硬件设计的能力)
3. 训练计算思维

#### 什么是计算思维 (Computational Thinking)
运用计算机科学的基础概念去求解问题, 设计系统, 理解人类的行为
1. 抽象 (Abstraction)
2. 自动化 (Automation): 将抽象思维的结果在计算机上实现
3. 分解 (Decomposition): 大规模 => 小规模
4. 递归 (Recursion): 特殊的分解, 小规模问题和大规模问题是一类问题, 规模足够小时解决特别简单
5. 权衡/折衷 (Tradeoff): 理论可实现 v.s. 实际可实现

### 1.3 编译过程
1. 词法分析 (类比: 识别出句子中的一个个单词)
2. 语法分析 (类比: 分析句子的语法结构)
3. 中间代码产生 (类比: 根据句子的含义进行初步翻译)
4. 优化 (类比: 对译文进行修饰)
5. 目标代码产生 (类比: 写出最后的译文)

#### 词法分析
任务: 对构成源程序的字符串进行扫描和分解, 识别出单词符号
依循的原则: (语言的)构词规则 (用自然语言描述, 不严格)
描述工具: 有限自动机 (用形式化的方法来描述)
例子: `for i := 1 to 100 do // 基本字, 标识符, 赋值号, 整常数, 基本字, 整常数, 基本字`

#### 语法分析
任务: 把单词符号串分解成各类语法单位/语法范畴
依循的原则: (语言的)语法规则 (用自然语言描述, 不严格)
描述工具: 上下文无关文法(用形式化的方法来描述)
例子: `z := x + 0.618 * y; // 算术表达式, 算术表达式, 赋值语句`

#### 中间代码产生
任务: 对语法单位按语言的语义进行初步翻译
依循的原则: (语言的)语义规则(用自然语言描述, 不严格)
描述工具: 属性文法(用形式化的方法来描述)
中间代码: 三元式, 四元式, 树, ...
例子: `四元式: OPR, OPN1, OPN2, RESULT, [序号, 注释]`

#### 优化
任务: 对中间代码加工变化, 以期产生更高效 (时间, 空间) 的目标代码
依循的原则: 程序的等价变换规则
例子: `编写代码可关注可读性, 交由编译器优化提高效率`

#### 目标代码生成
任务: 将中间代码变换成特定机器上的目标代码
依循的原则: 硬件系统结构与机器指令的含义
形式: 
   1. 汇编指令代码: 需要进行汇编
   2. 绝对指令代码: 可直接运行 (如: .exe)
   3. 可重定位指令代码: 需要链接 (如: .obj; 相对地址, 支持模块化开发)

### 1.4 编译程序的结构
1. 编译程序总框
2. 遍
3. 编译前端与后端

#### 编译程序总框
basic:
   1. 词法分析器 => 词法分析 => 单词符号
   2. 语法分析器 => 语法分析 => 语法单位
   3. 语义分析与中间代码生成器 => 中间代码
   4. 优化段 => 优化 => 高效的中间代码
   5. 目标代码生成器 => 目标代码
plus:
   1. 符号表管理
   2. 出错处理

#### 出错处理程序
发现源程序中的错误, 把错误信息报告给用户
1. 语法错误: 源程序中不符合词法, 语法规则的错误
2. 语义错误: 不符合语义规则的错误

#### 遍 (pass)
概念: 对源程序或其中间表示从头到尾扫描一次
与阶段的不同:
1. 一遍可以由若干段组成: 词法分析 & 语法分析 & 中间代码生成 可放在一遍
2. 一个阶段可以分若干遍完成: 优化可以分多遍

#### 编译前端与后端
以中间语言为界来划分
   1. 编译前端: 与源语言相关, 如: 词法分析, 语法分析, 语义分析与中间代码生成, 与机器无关的优化
   2. 编译后端: 与目标机相关, 如: 与目标机有关的优化, 目标代码产生
好处:
   1. 程序逻辑结构更清晰
   2. 优化更充分
   3. 便于移植

### 1.5 编译程序生成
1. 已有某语言的编译程序, 实现另一语言的编译程序
2. 编译程序的移植
3. 自编译方式
4. 编译程序-编译程序

## 2 高级程序设计语言概述

### 2.1 常用的高级程序设计语言
>> 略

### 2.2 程序设计语言的定义
程序本质上是一定字符集上的字符串;
程序本质上是描述一定数据的处理过程;
程序语言的基本功能是描述数据和对数据运算;
程序设计语言的定义有:
   1. 语法定义
   2. 语义定义
   3. 语用定义 (不涉及)

#### 语法定义
1. 概念: 语法是一组规则, 用它可以形成和产生一个合式 (well-formed, 形式上正确) 的程序 
2. 包括词法规则, 语法规则, 定义的是程序的形式结构 (定义语法单位的意义属于语义问题)

#### 语法定义之 -- 词法规则
1. 词法规则是单词符号的形成规则
2. 单词符号是语言中具有独立意义的最基本结构
3. 一般包括: 常数, 标识符, 基本字, 算符, 界符
4. 描述工具: 有限自动机

#### 语法定义之 -- 语法规则
1. 语法单元的形成规则
2. 一般包括: 表达式, 语句, 分程序, 过程, 函数, 程序
3. 描述工具: 上下文无关文法

#### 语义定义
1. 概念: 语义是一组规则, 定义一个程序的意义
2. 描述方法:
   1. 自然语言描述 (二义性, 隐藏错误, 不完整性)
   2. 形式描述 (操作语义, 指称语义, 代数语义 (不要求掌握))

### 2.3 高级程序设计语言的一般特性

#### 高级语言的分类
1. 强制式语言/过程式语言 (Imperative Language): 命令驱动, 面向语句
2. 应用式语言 (Applicative Language): 更注重功能, 从已有函数出发构造更复杂的函数
3. 基于规则的语言 (Rule-based Language): 注重谓词逻辑表达式, 满足条件执行适当动作
4. 面向对象语言 (Object-Oriented Language): 封装, 继承, 多态

#### 标识符 v.s. 名字
1. 标识符是语法概念, 名字是语义概念
2. 标识符通过绑定 (binding, 有静态绑定, 动态绑定) 关联对象成为名字

#### 名字
1. 名字具有意义和属性
   1. 意义/值: 单元中的内容
   2. 属性: 类型, 作用域
2. 名字的说明方式
   1. 通过说明语句 (int, var)
   2. 隐含说明
   3. 动态确定 (走到哪, 是什么, 算什么)

#### 表达式
表达式由运算量和运算符组成

#### 语句
1. 执行性语句: 定义
2. 说明性语句:
   1. 赋值句: :=
   2. 控制句:
      1. 无条件转移语句 goto
      2. 条件语句 if
      3. 循环语句 for, while
      4. 过程调用语句 call
      5. 返回语句 return
   3. 输入/输出句

## 3 高级程序设计语言的语法描述

### 3.1 上下文无关文法

#### 文法
描述语言的语法结构的形式规则
`<句子> -> <主语><谓语><间接宾语><直接宾语>; He gave me a book`

#### 语法描述的基本概念
1. 字母表: 一个有穷字符集, Σ (sigma)
2. 字符: Σ 中的每个元素
3. 字符串 (字): 由 Σ 中的字符所构成的一个有穷序列
4. 空字: 不包含任何字符的序列 (不是字符, 但是字), ε (epsilon)
5. 字的全体: Σ^*
6. 积 (连接, UV): `UV = {αβ | α∈U & β∈V}`, 积/连接是有顺序的
7. 自身的n次积 (V^n): 特别定义 `V^0 = {ε}`
8. 闭包 (V^*): `V^* = V^0 ∪ V^1 ∪ V^2 ∪ ...`
9. 正规闭包 (V^+): `V^+ = V V^*`; 如果V原来没有空字, 闭包有空字, 正规闭包无空字

#### 上下文无关文法 (G)
0. 上下文无关语法是G是一个四元组: `G = (V_T, V_N, S, P)`
1. V_T: 终结符(Terminal)集合
   1. 非空
   2. 终结符: 语言中不可再分的基本符号
2. V_N: 非终结符(Nonterminal)集合
   1. 非空
   2. 且 `V_T ∩ V_N = 空集`
   3. 非终结符(语法变量): 代表语法范畴, 代表一个一定的语法概念
   4. 一个非终结符是一个类(集合)记号, 而不是个体记号
3. S: 开始符号
   1. 是一个特殊的非终结符
   2. 代表我们最终感兴趣的语法范畴
4. P: 产生式集合
   1. 产生式(产生规则/简称规则)
   2. `P -> α, P∈V_N, α∈(V_T∪V_N)^*` 或 `P ::= α`

#### 上下文无关文法示例
```
G = <{i, +, *, (, )}, {E}, E, P>

i: 标识符
E: 表达式
P:
  E -> i
  E -> E + E
  E -> E * E
  E -> (E)

或 P:
  E -> i | E + E | E * E | (E)
```

#### 一些符号
大写字母或汉语: 非终结符
小写字母: 终结符
α, β, γ: 由终结符和非终结符组成的符号串, 或者 "句型"
->, ::=: "定义为"
|: "或"
=>: "直接推出"
=*>: "经过0步或若干步推出", 即 `= 或 =+>`
=+>: "经过1步或若干步推出"

### 3.2 文法与语言

#### 推导
直接推出: αAβ => αγβ, 仅当 A -> γ
推导: 从α_1到α_n的推导 (α_1 => α_2 => ... => α_n, α_1 推导出 α_n)
例子: `E => (E) => (E + E) => (i + E) => (i + i)`

#### 句型, 句子, 语言
1. 句型: 如果 S =*> α, α 是一个句型
2. 句子: 仅含终结符的句型
3. 语言: 文法G所产生的句子的全体 `L(G) = {α | S =+> α, α∈V^*}`

#### 最左推导, 最右推导
1. 最左推导: 任何一步 α => β 都是对 α 中的最左非终结符进行替换的
2. 最右推导: 同理

### 3.3 语法树与二义性

#### 语法树/语法分析树
1. 语法树的根结点由开始符号所标记
2. 当某个非终结符被它的某个候选式所替换, 会产生下一个新结点(每个新结与夫结都有一条连线)
3. 在任何时刻, 所有叶结点自左向右排列起来就是一个句型
4. 父子结点同名很正常, 反映了递归性

#### 二义性
1. 文法二义性: 如果一个文法中存在某个句子, 有两个不同的推导, 则这个文法是二义的
2. 语言二义性: 是语言层面的
3. 二义性问题是不可判定的
4. 文法二义性不一定是坏事

#### 形式语言鸟瞰
1. 0型文法: 短语文法, 能力相对与图灵机
2. 1型文法: 上下文有关文法, 对非终结符替换时务必考虑上下文
3. 2型文法: 上下文无关文法, 非确定的下推自动机, 使用下推表的有限自动机是分析2型文法语言的基本手段
4. 3型文法: 正规文法, 等价于正规式

## 4 词法分析_1

### 4.1 词法分析概述
词法分析的任务: 从左至右逐个字符地对源程序进行扫描, 产生一个个的单词符号, 把作为字符串的源程序改造成单词符号串的中间程序 `字符串 => 单词符号串`
执行词法分析的程序叫词法分析器

#### 词法分析器的功能
输入源程序, 输出单词符号
   1. 单词符号
     1. 关键字/保留字/基本字: 程序语言定义的具有固定意义的标识符
     2. 标识符: 表示各种名字
     3. 常数: 一般有整型, 实型, 布尔型, 文字型
     4. 运算符
     5. 界符: , ; () /
   2. 单词符号的表示: `<单词种别, 单词符号的属性值>`
     1. 单词种别: 一般用整数编码, 界定一符一种
     2. 单词符号的属性: 反应特性或特征的值, 常常是存放它的有关信息的符号表项的指针

### 4.2 词法分析器的设计

#### 词法分析器的设计
1. 给出语言的单词规范--单词表
2. 对照单词表设计识别该语言所有单词的状态转换图
3. 根据状态转换图编写词法分析程序

#### 词法分析器的构成
1. 输入缓冲区: 输入串一般会放在一个缓冲区里面, 词法分析工作可以在里面进行
2. 预处理子程序: 进行预处理, 输出确定长度的字符
3. 扫描缓冲区: 一分为二的区域(要对标识符长度进行限制), 两个指示器(起点指示器, 搜索指示器)
4. 扫描器: 输出单词符号

#### 状态转换图
是一张有限方向图

#### 将状态图的代码一般化
```
def curState // 保存现有的状态
def stateTrans[state][ch] // 状态图
def strToken // 单词符号

curState = 初态
GetChar()
while (stateTrans[curState][ch] 有定义) {
  Concat()
  curState = stateTrans[curState][ch]
  if (curState 是终态) {
    return strToken;
  }
  GetChar()
}
```

## 5 词法分析_2

### 5.1 词法规则形式化--正规集与正规式
要将转换图的概念形式化
对于字母表Σ, 感兴趣的是一些特殊字集(正规集), 使用正规式来表示正规集

#### 正规式与正规集的递归定义
仅由下面3个步骤得到的表达式才是 Σ 上的正规式;
仅由这些正规式所表示的字集才是 Σ 上的正规集;

1. ε 和 空集 都是 Σ 上的正规式, 它们所表示的正规集为 {ε}, 空集
2. 对任何 a ∈ Σ, a 是 Σ 上的正规式, 所表示的正规集为 {a}
3. 假定 U, V 是 Σ 上的正规式, 他们所表示的正规集为 L(U), L(V), 那么:
   1. (U | V) 表示 L(U)∪L(V)
   2. (UV) 表示 L(U)L(V)
   3. (U)^* 表示 (L(U))^*

#### 正规式等价
如果两个正规式所表示的正规集相同, 则二者等价

#### 例子: 根据单词表写出正规式
将每一类的单词表示为一个正规式
把这些正规式进行或运算

```
DIM | IF | DO | STOP | END | letter(letter|digit)* | digit(digit)* | ...

保留字 ∪ 标识符 ∪ 常数 ∪ ...
```